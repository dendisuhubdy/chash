#!/usr/bin/env python

import fnmatch
import glob
import threading
from subprocess import Popen, PIPE
import hashlib
import sys
import os
import re
import getopt

threads = 1
testcase_pattern = "*.c"
default_path = ".."
default_compile_command = "clang"
default_compile_flags = "-Wall"
default_hash_command = os.path.join(os.path.dirname(__file__), "../build/wrappers/clang-hash")

LOGLEVEL = 1
LOGLEVEL_DEBUG = 2
LOGLEVEL_NORMAL = 1
LOGLEVEL_QUIET = 0

console_lock = threading.Lock()

class COLOR:
    codes = ["BLACK", "RED", "GREEN", "YELLOW", "BLUE", "MAGENTA", "CYAN", "WHITE"]

    #following from Python cookbook, #475186
    @staticmethod
    def has_colours(stream):
        if not hasattr(stream, "isatty"):
            return False
        if not stream.isatty():
            return False # auto color only on TTYs
        try:
            import curses
            curses.setupterm()
            return curses.tigetnum("colors") > 2
        except:
            # guess false in case of error
            return False


    @staticmethod
    def format(text, colour="WHITE", bold = False):
        if type(COLOR.has_colours) is not bool:
            COLOR.has_colours = COLOR.has_colours(sys.stdout)

        """Colorize a string"""
        colour = COLOR.codes.index(colour.upper())
        bold = {True: 1, False: 0}[bold]
        if COLOR.has_colours:
            seq = "\x1b[%d;%dm" % (bold, 30+colour) + text + "\x1b[0m"
            return seq
        else:
            return text

def to_console(text):
    console_lock.acquire()
    sys.stdout.write(text)
    console_lock.release()

class Future:
    def __init__(self):
        self.value = None
        self.__set = False
        self.cond = threading.Condition()
    def get(self):
        if self.__set:
            return self.value
        self.cond.acquire()
        while not self.__set:
            self.cond.wait()
        self.cond.release()
        return self.value

    def set(self, value):
        self.cond.acquire()
        self.value = value
        self.__set = True
        self.cond.notifyAll()
        self.cond.release()


def test_case_open(test_case):
    try:
        fd = open(test_case);
    except:
        to_console(" Couldn't open test case: " + test_case + "\n")
        sys.exit(2)
    return fd

def get_tag(test_case, field, default = None):
    fd = test_case_open(test_case)
    value = default
    for line in fd.readlines():
        if field in line and ":" in line:
            value = line[line.index(":") + 1:-1].strip()
    fd.close()
    return value

def get_area(test_case, start, stop):
    fd = test_case_open(test_case)
    value = []
    dump = False
    for line in fd.readlines():
        if stop in line:
            dump = False
        if dump:
            value.append(line)
        if start in line:
            dump = True
    fd.close()
    return value

def get_variants(test_case):
    fd = test_case_open(test_case)
    content = fd.read()
    variant_pattern = "{{([a-zA-Z]+)(:.+?)?}}"
    variant_line_pattern = "{{([a-zA-Z]+)}}"

    variants = {}
    for variant in re.finditer(variant_pattern, content):
        variant = variant.group(1)
        line_tag = ("{{%s}}" % variant)
        # Is this variant already extracted?
        if not variant in variants:
            text = []
            for line in content.split("\n"):
                if re.search(variant_line_pattern, line):
                    if line_tag in line:
                        line = line.replace(line_tag, "")
                        text.append(line)
                    continue
                def replace(match):
                    if match.group(1) == variant:
                        assert match.group(2)
                        return match.group(2)[1:] # Strip ":"
                    return ""
                (line, _) = re.subn(variant_pattern, replace, line)
                text.append(line)
            variants[variant] = "\n".join(text)
    return variants


def run_testcase_cleaner(basename):
    cruftfiles=list()
    cruftfiles.extend(glob.glob(basename + ".*.o"))
    cruftfiles.extend(glob.glob(basename + ".*.var.c"))
    for cruft in cruftfiles:
        try:
            os.unlink(cruft)
        except OSError:
            pass
    return len(cruftfiles)

def run_command(cmd, stdin=None):
    output = "----- exec: " + cmd + "\n"

    p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    if stdin:
        p.stdin.write(stdin)
    (stdout, stderr) = p.communicate()
    if stdout:
        output += "----- stdout -----\n"
        output += stdout
    if stderr:
        output += "----- stderr -----\n"
        output += COLOR.format(stderr, "yellow")
    p.wait()
    return p.returncode, output, stdout, stderr

def run_testcase_helper(test_case, check_name, future):
    compile_command = get_tag(test_case, "compile-command", default_compile_command)
    hash_command = get_tag(test_case, "hash-command", default_hash_command)

    object_files_might_not_differ = get_tag(test_case, "obj-not-diff")

    compile_flags = get_tag(test_case, "compile-flags", default_compile_flags)
    variants = get_variants(test_case)

    basename, ext = os.path.splitext(test_case)

    # Add the testcase directory
    dirname = os.path.dirname(test_case)
    compile_flags += " -I %s" % (dirname)

    cruft = run_testcase_cleaner(basename)

    output = COLOR.format("TEST", "blue", True) + " %s: %s (%d leftovers removed)\n" % \
             (COLOR.format(test_case, "cyan"), COLOR.format(check_name, "yellow"), cruft)

    failed = False

    results = {}

    for variant in variants:
        source_file = "{basename}.{variant}.var{ext}".format(
            basename=basename,
            variant=variant,
            ext=ext)
        object_file = "{basename}.{variant}.var.o".format(
            basename=basename,
            variant=variant)

        # Dump variant file
        with open(source_file, "w+") as fd:
            fd.write(variants[variant])

        assert os.path.exists(source_file)

        cmd = "{compiler} -c -xc - -o {object_file} {flags}".format(
            compiler=compile_command,
            object_file=object_file,
            flags=compile_flags)
        (ret_compiler, x, _, __) = run_command(cmd, stdin=variants[variant])
        assert os.path.exists(source_file)

        if (LOGLEVEL >= LOGLEVEL_NORMAL and ret_compiler != 0) and ret_compiler != 0:
            output += x
        elif LOGLEVEL >= LOGLEVEL_DEBUG:
            output += x

        # Hash Object File
        object_hash = hashlib.sha1()
        if ret_compiler == 0:
            with open(object_file) as fd:
                object_hash.update(fd.read())
        else:
            output += COLOR.format("!!! Failed: compile (%s) failed with %d\n" % (variant, ret_compiler),
                                   "red", bold=True)
            failed = True
        object_hash = object_hash.hexdigest()

        #### Run Clang-Hash

        cmd = "{cmd} {source_file} {flags}".format(
            cmd=hash_command,
            source_file=source_file,
            flags=compile_flags)
        (ret_hasher, x, _, stderr) = run_command(cmd)
        if (LOGLEVEL >= LOGLEVEL_NORMAL and ret_hasher != 0) or LOGLEVEL >= LOGLEVEL_DEBUG:
            output += x
        ast_hash = None
        for line in stderr.split("\n"):
            if line.startswith("top-level-hash"):
                ast_hash = line.split(":")[1].strip()
        if ret_hasher != 0:
            output += COLOR.format("!!! Failure: clang-hash (%s) failed with %d\n" % (variant, ret_hasher),
                                   "red", bold=True)
            failed = True
        elif not ast_hash:
            output += COLOR.format("!!! Failure: Did not find top-level-hash in stderr\n",
                                   "red", bold=True)
            failed = True

        # Call clang-hash
        if LOGLEVEL >= LOGLEVEL_NORMAL:
            output += " {source_file} {object_hash} {ast_hash}\n".format(
                source_file=source_file,
                object_hash=object_hash,
                ast_hash=ast_hash)

        results[variant] = (object_hash, ast_hash)

    # Compare all hashes
    mapping = {}
    for var_1 in results:
        obj, ast = results[var_1]

        for var_2 in results:
            if var_2 <= var_1:
                continue
            other_obj, other_ast = results[var_2]
            if obj == other_obj and ast == other_ast:
                continue
            if obj != other_obj and ast != other_ast:
                continue

            if object_files_might_not_differ and obj == other_obj:
                continue

            output += COLOR.format("!!! Failure: Different hashes\n", "red", True)
            output += " {var_1} {obj} {ast}\n".format(**locals())
            output += " {var_2} {other_obj} {other_ast}\n".format(**locals())

            failed = True

    if failed:
        output += " Failed\n"

    to_console(output)

    future.set(tuple([not failed, output]))


def run_testcase(test_case, check_name):
    future = Future()
    if threading.active_count() >= threads:
        run_testcase_helper(test_case, check_name, future)
        future.get()
    else:
        t = threading.Thread(target = run_testcase_helper,
                             args = (test_case, check_name, future))
        t.start()
    return future

def run_test_suite(tests):
    tests_run = 0
    tests_failed = 0
    tests_known_fail = 0

    failed_tests = []

    for test_case in tests:
        check_name = get_tag(test_case, "check-name")
        if not check_name:
            to_console(COLOR.format("WARN", 'yellow', True) + " test '%s' unhandled\n" % test_case)
            continue
        failed_tests.append((run_testcase(test_case, check_name),
                       get_tag(test_case, "check-known-to-fail")))

    for (future, expected) in failed_tests:
        (passed, output) = future.get()
        if not passed:
            tests_failed += 1
            if expected:
                tests_known_fail += 1
        tests_run += 1
    to_console("Out of %d tests, %d passed, %d failed (%d of them are known to fail).\n" \
               % (tests_run, tests_run - tests_failed, tests_failed, tests_known_fail))

    return tests_failed <= tests_known_fail

def usage():
    print "%s [-c] [-t threads] [-q] [-v] [test-cases...]" % sys.argv[0]
    print " if no test-cases are given, all in current directory are run"

def get_testcases():
    all_files = []
    for root, subFolders, files in os.walk("."):
        for file in files:
            path = os.path.join(root, file)
            if fnmatch.fnmatch(path, testcase_pattern) and not "var.c" in file:
                all_files.append(path)

    return sorted(all_files)

if __name__ == '__main__':
    opts, args = getopt.getopt(sys.argv[1:], "ht:qcv")

    for opt,arg in opts:
        if opt in ('-c', '--clean'):
            tests = get_testcases()
            for test in tests:
                basename,_ = os.path.splitext(test)
                run_testcase_cleaner(basename)
            sys.exit(1)
        if opt in ('-t', '--threads'):
            threads = int(arg)
            if threads < 1:
                print "invalid thread_count"
                usage()
                sys.exit(1)
        elif opt in ('-h', '--help'):
            usage()
            sys.exit(0)
        elif opt in ('-q', '--quiet'):
            LOGLEVEL = 0
        elif opt in ('-v', '--verbose'):
            LOGLEVEL = 2
        else:
            print "unkown option"
            assert False

    if len(args) > 0:
        ret = run_test_suite(args)
    else:
        ret = run_test_suite(get_testcases())

    if ret:
        sys.exit(0)
    else:
        sys.exit(-1)
