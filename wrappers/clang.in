#!/usr/bin/python

import sys
import os
import hashlib
import logging
import re
import time
from subprocess import *

outputDir = os.path.abspath("${PROJECT_BINARY_DIR}/muslHashes")

def mkpath(path):
    try:
        os.makedirs(path)
    except OSError:
        pass

if __name__ == "__main__":
    args = sys.argv[1:]
    level = logging.INFO
    if "V" in os.environ:
        level = logging.DEBUG
    logging.basicConfig(filename = "clang-hash.log", level=level)
    logging.debug(str(sys.argv))

    compiler = "${LLVM_C_COMPILER}"
    plugin = "${PROJECT_BINARY_DIR}/src/libclang-hash.so"

    start_time = time.time()
    x = Popen([compiler, "-fplugin=" + plugin] + args,
              stdin=sys.stdin, stdout=PIPE, stderr=PIPE)
    (stdout, stderr) = x.communicate()
    compileTime = (time.time() - start_time) * 1e9 # nano
    sys.stdout.write(stdout)
    sys.stderr.write(stderr)
    retcode = x.wait()

    if "-c" in args and "-o" in args and "/dev/null" not in args:
        # Save Objectfile data
        objectfile = args[args.index("-o")+1]
        objectfile_hash = None
        if os.path.exists(objectfile):
            objectfile_hash = check_output(["${PROJECT_BINARY_DIR}/wrappers/hash-objectfile", objectfile]).strip()
            objectfile_data = open(objectfile).read()
        else:
            objectfile_data = None

        # Just use to set commit hash and project identifier from the outside
        # PROJECT=musl COMMIT_HASH=`git log -1 --pretty="%H"` make
        record = {
            'project': os.environ.get("PROJECT"),
            'time': time.time(), # Record current time to always find the most recent record.
            'commit-hash': os.environ.get("COMMIT_HASH"),
            'filename': args[-1], #TODO: does this assumption hold?
            'return-code': retcode,
            'compile-duration': compileTime,
            'object-hash': objectfile_hash,
            'start-time': start_time,
            'object-file-size': os.stat(objectfile).st_size,
        }

        lines = stderr.split("\n")
        for line in lines:
            if line.startswith("top-level-hash"):
                record['ast-hash'] = line.split()[1]
            elif line.startswith("processed-bytes:"):
                record['processed-bytes'] = int(line.split()[1])
            elif 0 == line.find("hash-time-ns:"):
                record['hash-duration'] = int(line.split()[1])
            elif line.startswith("parse-time-ns:"):
                record['parse-duration'] = int(line.split()[1])
            elif line.startswith("element-hashes:"):
                data = line[len('element-hashes:'):]
                try:
                    record['element-hashes'] = eval(data)
                except RuntimeError as e:
                    print e
                    pass
            elif line.startswith("hash-start-time-ns"):
                record['hash-start-time'] = int(line.split()[1])

        outputPath = outputDir + "/" + os.path.dirname(objectfile)
        mkpath(outputPath)
        f = open(outputDir + "/" + objectfile + ".info", 'a')
        f.write(repr(record) + "\n")
        f.close()


    sys.exit(retcode)
